
<html>

<head>

@@default-style
@@font-style

</head>

<body>

<!-- <div id='top-picture'>

<div id='picture-offset'>


-->

<div id='top-offset'>


@@top-links-banner


<!-- </div> <!-- picture offset -->


</div> <!-- top offset -->


<div id='main-page-title-div'>

<div class='center-wrap top-offset-5vh'>

<h1 class='main-page-title'>
Mobile Medical User Interface (#(MMUI)#)
</h1>

</div>

</div>


<div id='main-page-body-div'>

<p>
Mobile Medical User Interface (#(MMUI)#) is a framework for 
building #(GUI)# classes for medical software front-ends and 
for creating native applications that share biomedical data.  
#^(MMUI)# seeks to adapt the kind of technology one finds in clinics and
hospitals for use in smaller-scale applications *[in the field]*,
including for researchers and doctors working in poor or remote
communities with limited resources.  This includes providing quality
medical imaging and visualization and #(EHR)# capabilities without relying
on a continuous web connection or hosting the application in a web
browser; sensible patient record and management systems; and 
flexible peer-to-peer networking.  
Compared to products from #(EHR)# vendors, #(MMUI)# 
is more modular, extensible, packages many
useful libraries, and (as a standalone program) does not suffer from
in-browser limitations.  
</p>

<p>
#^(MMUI)# is targeted at research and clinical networks with
heterogenous endpoints, from well-provisioned labs and
offices to field locations with more limited computing
environments.  #^(MMU)# improves on #(HIT)# and #(EHR)# 
solutions in several ways.  First, native-driven front-ends provide a
superior User Experience (#(UX)#) to browser-based front-ends, because they can more
effectively use context menus; dialogs, wizards, and other
topic-specific window controls; embedded #(3D)# and multimedia; and can
more aggressively apply strong-typing optimizations to classify and
manage web-based data.  For example, wrapping web #(API)#s in
strongly-typed client libraries allows each #(API)# and its visual
interface (its model/view pair) to be packaged in modular fashion and
reused in multiple applications.
</p>

<p>
#^(MMUI)# embraces a philosophy wherein applications are shared among 
specialists in a single field, rather than shared only within a 
single provider network or #(EHR)# system.  For example, all radiologists 
have the same requirements when working with diagnostic images.  
An #(MMUI)# application can accordingly be designed 
specifically for radiologists.  By ensuring that such an application 
is cross-platform and has few additional dependencies, 
meaning that no special libraries are required 
to run the application (such as the #(VTK)# --- the 
*[Visualization Toolkit]* --- or similar graphics and/or 
data management libraries).  Because of this, any radiologists 
can use such an application regardless of the kind of office they 
occupy or the kind of computer they have.  Using #(MMUI)#, when multiple 
radiologists need to consult remotely (e.g., via  
teleconferencing), they will be able to share the same application, 
inhering the same screens and capabilities.  Applications in this sense 
are orthogonal (agnostic and independent) to any particular #(EHR)# vendor, 
network, or system: they may draw information from a network, but are 
installed and used apart from vendor-specific #(EHR)# networks.  
This ensures that there are no restrictions on multiple 
radiologists (for example) working collaboratively.  In 
particular, this avoids the all-too-common situation where doctors 
cannot access out-of-network records or images, because they 
are not participating doctors in the hospital from which a diagnostic 
study was initiated.  #^(MMUI)# eliminates having 
to resort to primitive methods, such as fax machines, to send 
data between disparate offices.
</p>

<p>
By concentrating applications on individual specialists' netwoks, 
#(HIT)# software also becomes a conduit for innovations in medicine and 
in bioinformatics to propagate among practitioners.  Whenever a researcher 
discovers a new computational technique (such as applying Artifical Intelligence 
to problems in diagnostics, genomics, or predicative analysis), 
or a doctor develops a new treatment regimen, new data structures 
emerge that must be handled by medical software.  In fact, each innovation 
introduces new data models that must be assembled prior to the innovative 
techniques being applied.  Innovations also generate new kinds of 
data in the form of result sets generated as their new techniques 
are applied.  To support such innovations, medical databases 
need to provide the data required by the innovative components, 
and information generated by these components must be 
properly shared and maintained.  A platform like #(MMUI)# serves 
innovators because it becomes possible to create 
software specifically targeted to innovation-specific data 
models, or to leverage existing subject-specific 
application networks to promote the innovations.  For example, 
innovative methods in the field of radiology can be 
propagated by adding capabilities to radiology-specific 
applications.  If these applications are widely used, 
it empowers a wider set of doctors to adopt and benefit 
from the innovations.  Properly construction Application 
Networks eliminate the bureaucratic inertia that 
can delay new discoveries from benefiting patients.
</p>

<p>
Given these considerations, #(MMUI)# embraces and advocates 
for *[Innovation-Centric Design]*, meaning that software 
systems, components, and applications should be designed 
to facilitate rather than impede the adoption of 
innovative practices and discoveries in fields like 
biology and medicine.  Innovation-Centric Design means 
that application networks are poised to incorporate new 
data models into their data-sharing capabilities.  This 
affects design choices on both front-end and back-end 
components.  On the front end, #(GUI)# design needs to 
be modular, where distinct visual components and dialog 
classes can be developed in response to innovations and 
incorporated semi-autonomously into both new and existing 
software.  For example, a new analytic methodology in the 
radiology field can be packaged into several #(MMUI)# dialog 
classes and made aviailable for use by existing #(MMUI)# 
applications.  On the other hand, on the back-end, data providers 
need to deliver data sets packaged into a format directly usable 
by the front-ends through which innovations are 
operationalized.  It is a burden on application developers to 
piece together complex data structures by sending and 
post-processing multiple requests to a data source.  
Back-end failure to support type-specific data requests adds complexity 
and costs to front-end development, even if  
a data source makes the requisite information available 
in isolated pieces.  
</p>

<p>
Innovation-Centric Design 
means that a single field value --- for example, one which 
identifies a single data type --- provides enough information 
for a data provider to know exactly which information 
needs to be included in the response to a query.  For example, only 
certain fields in individual patient records will be relevant for 
radiologists --- so, to best serve radiologists, data providers 
should implement response-builders specifically for 
responding to queries originating from software used by 
radiologists.  This can be facilitated by implementing data models 
in autonomous code libraries.  Each libary will carry a distinct 
signature, to identify the specific kinds of 
information required by applications requesting data from a 
provider via that library.  Innovation-Centric Design means that 
the primary medium for data sharing is library-specific 
network code, rather than query languages, which unavoidably 
demand extra initialization and post-processing steps.  
Accordingly, data providers need to dynamically add new 
type-specific and library-specific capabilities.    
This means that data providers need to have the overall capability 
of incorporating new code libraries that implement new data types.  
</p>

<p>
As the prior discussion illustrates, modular design principles apply on the back-end 
as well as the front-end.  In the same way that front-end modules 
represent semi-autonomous bodies of code which present specific 
kinds of visual components in the context of pre-existing 
#(GUI)# applications, back-end modules represent semi-autonomous 
libraries that enable data to be obtained from a database and 
packaged according to type-specific protocols.  By continuously 
adding new libraries, back-ends can efficiently serve the 
needs of many different data-sharing networks.  
Current Medical Information Technologies place an emphasis on 
variegated, heterogeneous data stores, where 
many kinds of information can coexist without the 
limitations of Database Schema or other predefined data 
structures.  These data spaces, such as *[Semantic Data Lakes]* 
(#(SDL)#), can store data in many forms, including binary representations 
specific for individual peer-to-peer networks.  
The Application Semantic Kernel (<a href='/web/main-info-pages/ask.html'>#(ASK)#</a>) 
and Multi-Paradigm Semantic Modeling Engine 
(<a href='/web/main-info-pages/msme.html'>#(MSME)#</a>) are #(NDP)# components 
formulated to help data providers anchor networks 
designed according to these principles.  In particular, #(ASK)# can 
help developers create *[kernel]* libraries that distribute 
capabilities to share and respond to data with specific types; 
and #(MSME)# provides Semantic Graph models to help 
develop typed-query capabilities to #(SDL)#-style spaces.
</p>


<p>
#^(MMUI)# encourages a modular 
design where new, project-specific components can be added to 
existing applications, in the form of new dialog boxes, new 
networking capabilities --- allowing the application to 
participate in new data-sharing networks --- and/or new 
features available on the application main window.  
As such, #(MMUI)# can also be used as a plug-in for pre-existing
software, adding specific capabilities while remaining isolated from
the host application.  With such a
modular approach to application design, any
specific product delivered to a use-community can be assembled from
just those parts that are needed and customized as necessary.  At 
the same time, new components can be added later to 
extend a prior application.  Therefore when developing a new 
software capability or a new data sharing initiative, different 
pre-existing applications can help promote new initiatives by 
serving as a background application within which the new 
data and capabilities can be accessed.  
</p>

<p>
Another area where #(MMUI)# offers an advantage is for data modeling and
runtime data management.  Runtime layers to relational databases are
familiar via Object-Relational Mapping (like ActiveRecord for Rails or
#(LINQ)# for #(C#)#), but there is no analogous "Object Mapping" paradigm for
working with heterogenous, #(NoSQL)# back-ends, especially graph-based
back ends.  #^(MMUI)# provides a runtime data management layer first
through taking advantage of an embedded (and innovative) database
project called WhiteDB, which is similar to Semantic Graph engines
--- in that it combines several NoSQL
models, like document/#(XML)#-based, 
Column-based, and graph-based --- but
does so as an embedded non-socket-based engine.  In addition, 
by using the *[sister]* project #(MSME)#, #(MMUI)# applications 
allow programmers to manipulate runtime data
obtained from #(RDF)# and other semantic graph resources (with a
convenient programming interface that goes beyond basic #(SPARQL)# and
*[triple]* management of the kind you get with conventional triplestore
managers like Redland).  This kind of multi-paradigm #(NoSQL)# foundation
is increasingly important for #(HIT)#, as demonstrated for example by
large-scale *[Semantic Data Lake]* projects.
</p>

<h2>Overview of #(MMUI)# components</h2>

<p>
By design, the #(MMUI)# classes are not complete implementations but are 
templates and project outlines to be customized for each 
deployment.  Here are several components that can 
be incorporated into typical #(MMUI)# applications:
</p>

<ul>
<li>
<img src='/pics/te2.jpeg' class='li-image' alt='loading...'>
Patient Intake Form:  Used to gather patient information when first entered into the system.  
Many offices still use hard-copy forms for this purpose, but working directly 
with digitized forms reduces the time needed for subsequent data entry.  
This is particularly appropriate for medical applications 
*[in the field]*, where community organizations or volunteer groups 
like #(MSF)# are actively involved at the point-of-care, helping 
new patients who may be unfamiliar with the bureaucratic procedures of 
Western medicine.  #(MMUI)# forms and applications are designed to run on 
equally well on laptop computers that can be carried to ad-hoc medical 
settings as on full-featured computers in an office.
</li>

<li>
<img src='/pics/combo-box.jpeg' class='li-image' alt='loading...'>
Surgical and Treatment History:  A Native-Driven Dialog Window 
has a more sophisticated interactive interface that can be useful 
when working dates and enumerated lists.  Popup calendars can be 
fine-tuned for the needs of the application, and text entry areas 
can be broken down into individual lines or fields for creating 
lists (such as lists of surgeries).  This allows automatic 
numbering, insertion, and deletion of lines, and 
drag-and-drop for reordering lines.  Native dialogs can also 
do a better job of helping users navigate through the 
codes and terminologies which are endemic to biomedical data in 
particular.  
</li>


<li>
<img src='/pics/pain-markings.jpeg' class='li-image' alt='loading...'>
Indicating Pain and Symptoms:  #^(MMUI)# includes a useful 
dialog class for marking areas of pain, or areas with a presentation 
of other symptoms for use with different kinds of diagnostic procedures.  
The default class uses #(Qt)#-generated symbols to indicate kinds of 
pain and #(SVG)# backgrounds to focus on different anatomical areas 
(torso front and back, head and feet left and right); the dialog 
can then be customized by selecting different #(SVG)# backgrounds 
and/or generating different foreground symbols.  The symbols 
are annotated with modifiers describing the intensity and 
duration of the pain (whether the pain is constant, intermittent, or occasional).
</li>

<li>
<img src='/pics/pdf-capt.jpeg' class='li-image' alt='loading...'>
Digitizing #(PDF)# Forms:  Another #^(MMUI)# class is a 
#(PDF)# viewer that includes a feature for converting handwritten 
forms to digital text.  Instead of converting the entire form, this 
functionality allows users to *[prepare]* a form by creating a 
*[stencil]*: that is, a series of rectangular fields which mark 
where handwritten entries on a completed form will have 
info to be digitized.  The viewer can apply the stencil to scanned 
forms and use an #(OCR)# (Optical Character Recognition) library to 
convert the handwriting found specifically in the saved rectangular 
areas.  This generates a much more accurate digitization by trying to 
perform #(OCR)# on the entire form, with a mixture of print and 
handwritten text.
</li>


<li>
<img src='/pics/local-save.png' class='li-image' alt='loading...'>
Saving Forms and Sessions:  #^(MMUI)#'s use of Binary #(API)#s 
--- which simplify the process of sharing data between applications 
--- is also helpful for users who want to save and restore their 
session.  #^(MMUI)# creates a compact, binary representation of 
all data users have entered since starting the application, as 
well as user information and preferences.  This information can 
be shared over a network, or saved on the cloud; it can also be 
stored locally in a database attached to the #(MMUI)# application, 
or saved as a file on the user's computer.  The latter option 
gives users the choice of storing their #(MMUI)# sessions in 
locations and according to operations they understand 
(saving and loading files from their local filesystem).  
Saving in a local database is another option, which can free 
users from having to do an explicit save or open, but also 
is less transparent to users because the database is not 
found in the ordinary file system, and cannot be directly 
managed by non-expert users.
</li>

<li>
<img src='/pics/checks.jpeg' class='li-image' alt='loading...'>
Embedded #(HTML)# Viewers:  Some kinds of information or data entry 
is well-suited for #(HTML)# pages.  #^(HTML)# forms, for example, 
have useful styling options which can make them a good choice 
for information screens with many radio buttons or check boxes.  
Enabling embedded presentation of web pages --- where native 
code intercepts and interprets user actions (such as 
clicking on a hypertext link) --- allows application developers 
to take advantage of #(HTML)# features when desired but without 
forcing developers to accept the limitations of browsers and 
JavaScript.
</li>

<li>
<img src='/pics/text.jpeg' class='li-image' alt='loading...'>
Extended Text Entry:  Rather than having to fit their responses 
into one-line text fields, user can type multi-line comments 
into text fields.  Unlike #(HTML)# text area, native text areas 
can be detached into separate windows and *[float]* above other 
text and graphics --- for example, users can see the text where 
they describe medical symptoms while also looking at their 
markings on a graphical representation of pain areas.  
Being able to reposition and enlarge the text entry area helps 
users feel comfortable with entering as much text as they'd 
like, giving a more thorough description of their symptoms.
</li>


<li>
<img src='/pics/infobuttons.png' class='li-image' alt='loading...'>
Infobuttons:  Context-Aware Knowledge Retrieval (#(CAKR)#), also called 
*[infobuttons]*, allows users to research a medical term or code.
Some hospitals provide complex #(Infobutton Managers)# which 
allow context-sensitive investigations, where the results for a 
given user query are determined by the users' current task in the 
context of a predefined treatment protocol.  Outside of 
hospitals, similar research is possibe using public web services, 
such as MedLinePlusConnect.  #^(MMUI)# applications enable Infobuttons 
by allowing phrases to be selected from dialog windows and #(PDF)# 
or #(HTML)# documents, and then (via context menus) selecting an 
option to activate an Infobutton dialog box including 
basic search information and *[refinement]* terms.

</li>


<li>
<img src='/pics/enl.jpeg' class='li-image' alt='loading...'>
Supporting #(PACS)# Systems:  #^(MMUI)# allows capabilities of 
full-featured #(PACS)# systems to be adopted for local medical 
offices and clinics, even if they do not have access to expensive 
technology.  However, given that some forms of medical images are naturally 
suited to a context where radiologists and clinicians 
need to *[mark up]* images to point out suspicious findings, 
they need to have #(PACS)# capabilities at their disposal 
(for example, radiologists will mark up images 
as with arrows or semi-transparent overlays to 
indicate findings).  #^(PACS)# support should be 
available to all doctors and delivered in ways which are 
easy to use.  
#^(MMUI)# enabe broad-based #(PACS)# and also adds or 
enhanced #(PACS)# for optimal User Experience.  
</li>

<li>
<img src='/pics/drag-and-drop.jpeg' class='li-image' alt='loading...'>
Enhancing #(PACS)# Systems:  Radiologists need to mark up images, 
such as with arrows and overlays, to indicate suspicious 
findings.  For example, it can be difficult or impossibe 
to modify some aspects of the appearance of arrows, such as their 
color, rotation angle, and the dimensions of the shaft and the head.  
#^(MMUI)# ensures that a full-featured, highly interactive 
interface is available to all users, so that they can perform 
intricate editing operations (without needing expensive computers 
or a well-provisioned office).  At the same time, it delivers functionality 
in convenient, user-friendly ways, with a priority 
on features such as: *[drag-and-drop]*, 
*[drag-and-rotate]*, context menus, and Multiple-Window 
Display (#(MWD)#) with movable and resizable windows.
</li>


<li>
<img src='/pics/annotations-dialog.png' class='li-image' alt='loading...'>
Annotations:  
#^(MMUI)# supports image annotations 
via dialog boxes where a single diagnostic image would occupy a central 
area alongside buttons to activate different kinds of annotations.  
For images which are part of a larger study, 
other miniaturized images may be previewed in a strip from which 
a focal images is selected.  
<br>
<br>
<b>How Does This Work?</b>
<br>
<br>
First, annotations, such as arrow-markings, 
are then added to the image by clicking on corresponding buttons 
representing annotation types, such as arrows, comments, and rules.  
<br>
<br>
Second, annotations such as arrows position and geometry is then 
controled by a combination of 
mouse-actions and context menus.  
<br>
<br>
Third, different *[toggle]* 
buttons --- ones which when pressed remain in a 
*[down]* state until released --- are used 
to determine how mouse movements are linked to 
operations.  For example, *[Pan]* actions move an annotation 
to different positions against an image; *[Zoom]* actions resize an 
annotation; and *[Rotate]* actions change an arrow's 
pointing direction.
<br>
<br>
#^(MMUI)# supports a 
*[drag-and-rotate]* operation where arrows are 
rotated around the central point on the back line 
of their shaft.  Toggle buttons control whether 
mouse movements produce pan, zoom, or rotate 
effects.  In addition, #(MMUI)# supports 
manipulation of groups of arrows: drawing arrows 
closer to or farther away from a central point, 
or creating groups of arrows around a center point 
on the basis of one single arrow.  
<br>
<br>
As such, these 
are new capabilities that enhance the functionality 
of #(PACS)# systems.
</li>


<li>
<img src='/pics/tool-tip.jpeg' class='li-image' alt='loading...'>
Data Updates and Provenance:  Medicine is an area where many 
contributors may potentially want to edit or 
correct data, and where data integrity and security 
can be extremely consequential.  This places 
extra burdens in #(HIT)# technology, since 
medical software should give qualified users an 
opportunity to signal when they find data which appears 
to be incorrect or somehow flawed, but should also 
carefully monitor who/why/when data is altered.  
In effect, this suggests a system where users can 
flag information that they believe needs to be corrected.  
However, in many cases their edits will need to be reviewed 
before being incorporated into electronic medical records.  
Moreover, this needs to supported at a finely granular 
level --- it is not enough for a doctor to 
recommend changing a chunk of text or revising a numeric 
quantity; the specific edit needs to be notated 
in terms of an underlying data structure.  For example, 
a numeric quantity 
can represent a length of time, the dosage of a medicine, 
a biomedical measurement (heart rate, blood pressure, 
temperature, and so forth): a proposed edit to 
each kind of quantity is in essence a data structure which should 
be considered specifically in relation to the underlying 
data type.  A proposed edit to a measurement of dosage, 
for example, is distinct, as a data type, from a proposed 
edit to a duration of time during which a set of symptoms 
are present, which is a different data type.  
Via context menus and strong type-correspondance between front-ends 
and back-ends, server-side components, #(MMUI)# allows medical information 
systems to be designed with particular emphasis on tracking 
provenance and double-checking both existing data and 
edits made with regard to data.

</li>

</ul>


</div> <!-- main page div -->
</body>
</html>


