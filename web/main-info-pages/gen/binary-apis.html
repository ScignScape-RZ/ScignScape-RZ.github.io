
<html>

<head>


<!-- situation where the stylsheets are being loaded properly ...
-->

<style>

div.main-image-wrapper {text-align:center}

img.large-image {width:500px;} 

img.main-image {width:300px;} 

img.li-image {width:200px;float:left;padding-right:25px;padding-top:10px;} 


.tterm {font-family:Aldrich;color:rgb(90, 10, 20);font-size:90%}
.acronym { font-size:88% }
.acronym-cap { font-size:94% }

#main-page-body-div { border: ridge rgb(254, 157, 4) 20px; padding:40px; padding-left:48px; 
                      border-top: ridge rgb(254, 157, 4) 2px; 

  margin-top:4vh; margin-left:12vh; margin-right:15vh;  margin-bottom:30vh; } 

#main-page-body-div p { font-size:14pt; font-family:Podkova}

#main-page-body-div p:not(.continue) {text-indent:3em;} 

#main-page-body-div a { font-size:13pt; font-family:Podkova; letter-spacing:0px;}

#main-page-body-div li { font-size:12pt; font-family: Quattrocento; 
  margin-top:35px; font-weight:700}

  
a b {position:relative;left:4px;padding-left:4px;}

#logo{height:50px;margin-left:10px;margin-top:-1px;margin-bottom:-15px;}

div#top-container-first-row
{
 background:rgb(6,36,30); 
}

span.top-banner-label-group
{
 border-top:ridge rgb(179, 0, 0) 3px; margin-left:2px; margin-right:45px;
}


span.top-banner-label
{
 margin-left:5px;  padding-left:2px;padding-right:2px;
 color:rgb(25,22,25);font-family:Quattrocento;font-weight:900;font-variant:small-caps;
 position:relative;top:-2px;  border-bottom:solid rgb(255, 149, 102) 2px;  
 border-top:solid rgb(255, 129, 102) 2px;  
}

span.top-banner-label span
{
 padding-left:7px;padding-right:4px;
 background:rgb(255, 159, 102);
 border-top:solid rgb(25, 139, 102) 1px; border-bottom:solid rgb(25, 139, 102) 1px;
}

span.top-banner-segments
{
 margin-left:10px;
}


span.top-banner-link
{
 background:rgb(40,40,43);color:white;
 font-family:Podkova;font-weight:800;position:relative;top:-3px;
 border-bottom: solid rgb(90,90,90) 1px;
}

span.top-banner-link a
{
 background:rgb(40,40,43);color:white;
 margin-left:5px;margin-right:20px;padding-left:10px;padding-right:10px;
}


span.top-banner-link:hover
{
 background:rgb(66, 206, 244);color:rgb(20,20,43);
}

span.top-banner-link a:hover
{
 background:rgb(25, 206, 244);color:rgb(20,20,43);
}





.center-wrap { text-align:center; }

.top-offset-5vh { position:relative;top:5vh; }

div#top-offset { position:relative;top:5vh; }

hl.main-page-title { }




#top-picture {background-image: url("https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcRXk4HqTXQiPoab7TkJfF7qpznSSy7I0n66aWYloHAAnDZvsthB");
#no-repeat center center fixed;
background-size: 100% 100%;
height:150vh
}

#picture-offset { position:relative;top:5vh; }

#text-opacity {background-color:rgba(255,255,255,0.2);
padding-top:10px;
padding-bottom:50px;
}


div.top{
 padding-top:5vh;
 display:inline-block;
 text-align:right;width:21%;
 border-left:ridge rgb(230,230,230) 3px; 
 border-right:ridge rgb(230,230,230) 3px; 
 margin:0;
 padding-bottom:0px;
 margin-left:0;
 margin-right:0;
 padding-left:0;
 padding-right:2%;
 font-size:14pt;
 font-family:Aldrich;
 font-weight:600;
 }
 
 div.top span{background:rgba(255,255,255,0.6);padding:20px;padding-top:2px;font-size:12pt;line-height: 2.5em;}
 
 
#top-1{background:rgba(210,210,230,0.45);} 
#top-2{background:rgba(230,210,210,0.45);position:relative;left:-1%;} 
#top-3{background:rgba(210,230,210,0.45);position:relative;left:-2%;} 
#top-4{background:rgba(235,210,235,0.45);position:relative;left:-3%;width:25%} 

 
#top-offset{line-height:200%;margin:0%;padding:0%;background:"rgba(200,200,200,0.4);"}

#top-container-first-row{width:100%; overflow: hidden;background:rgba(200,200,200,0.4);
margin:0;padding-bottom:0; padding-top:4px;
border-top:double rgb(97,122,165) 3px;
border-bottom:ridge rgb(230,230,230) 3px; 
}

#top-background {background:rgb(97,122,165);position:absolute;top:-5vh;height:5vh;z-index:-1;width:100%}

#top-container-first-row span.home-wrapper{font-size:8pt;font-weight:900;position:relative;left:-6px;background:white;}

#top-container-second-row{margin-top:1px;width:100%; 
margin:0;padding-bottom:0;
overflow: hidden;background:rgba(200,200,200,0.4)}
 
#mmui{margin-top:2vh;position:relative;text-align:center;
font-weight:900; font-family:Nova Square;
   letter-spacing: 2px; 
   font-size:22pt;
   } 


#mmui span {border-bottom:groove rgba(100,100,50,0.5) 5px; color:rgb(66, 44, 5);
 background:rgb(245,245,245);
padding-bottom:5px; padding-left:10px;padding-right:10px;}

button {cursor:pointer}
   
#overview-list {position:relative; 
 text-align:left;left:50%;}


#overview-list  ul {
  list-style: inside square;
  padding-left:0;
  margin-left:0;
}

#overview-list  li {background:rgba(245,245,245,0.8);padding-left:10px; }
#overview-list  li span {font-family:courier;font-size:12pt;font-weight:900; }


#overview {position:relative;left:50%;text-align:left;
 margin-top:1vh;font-family:times;font-size:18pt;}
 
 #overview a {background:rgba(235,235,225, 0.7); border:inset rgb(255, 159, 102) 3px; 
  font-family:Quattrocento; border-radius:16px; padding-top:4px;padding-bottom:2px;}

#photo-credit span{background-color:rgba(160,0,0,0.8);color:white}
#photo-credit a{background-color:rgba(255,255,255,0.8)}
 
.raise-button{ position:relative;top:-4px;left:2px; }  
 
</style>


<meta http-equiv = "X-UA-Compatible" content = "IE=8,chrome=1">




<link rel = "stylesheet" href = "/sr__css/default-style.css" type = "text/css">


<!--[if IE]><link rel = "stylesheet" href = "/sr__css/default-style-ie.css" type = "text/css">
<![endif]-->
<!--[if !IE]><!-->
<!--<![endif]--></link>
<!--[if IE]></link>
<![endif]-->

</meta>

<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Aldrich" />
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nova+Square" />
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Podkova" />
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Quattrocento" />

<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Dancing+Script" />
 

</head>

<body>

<!-- <div id='top-picture'>

<div id='picture-offset'>


-->

<div id='top-offset'>



<div id='top-background'> 
</div> 

<div id='top-container-first-row'>

<a href='/web/index.html'>
<img id='logo' src='/pics/logo.png'/>
</a>

<span class='home-wrapper'><a href='/web/index.html'>
(HOME)</a></span>


<span class='top-banner-segments'>

<span class='top-banner-label-group'>

<span class='top-banner-label'>
<span>
Features:
</span>
</span>

<span class='top-banner-link'>
<a href='/web/main-info-pages/gen/hypergraph-database.html'
onclick="window.open('/web/main-info-pages/gen/hypergraph-database.html','_self'"
>
Hypergraph Database
</a> 
</span>

<span class='top-banner-link'>
<a href='/web/main-info-pages/gen/binary-apis.html'
onclick="window.open('/web/main-info-pages/gen/binary-apis.html','_self');"
>
Binary APIs
</a>
</span>

</span>


<span class='top-banner-label-group'>
<span class='top-banner-label'>
<span>
Info:
</span>
</span>

<span class='top-banner-link'>
<a href='/web/main-info-pages/resources.html'
onclick="window.open('/web/main-info-pages/gen/resources.html','_self');"
>
Resources and Articles
</a>
</span>


<span class='top-banner-link'>
<a href='/web/main-info-pages/contact.html'
onclick="window.open('/web/main-info-pages/gen/contact.html','_self');"
>
Contact
</a>
</span>

</span>

</span>

</div>



<!-- </div> <!-- picture offset -->


</div> <!-- top offset -->


<div id='main-page-title-div'>

<div class='center-wrap top-offset-5vh'>

<h1 class='main-page-title'>
Binary APIs with the Native-Driven Platform
</h1>

</div>

</div>


<div id='main-page-body-div'>

<p>
The term <span class='xquote'>&ldquo;Application Programming Interface&rdquo;</span> (<span class='acronym'>API</span>) refers both to 
how applications access local code libraries and to how they access 
information and services available over a network (such as the World 
Wide Web).  In the former sense, <span class='acronym'>API</span>s are generally <span class='xquote'>&ldquo;binary&rdquo;</span> in 
that they assume binary representations of data structures are 
passed directly to library functions.  On the other hand, web 
<span class='acronym'>API</span>s are generally textual (rather than binary) because the 
requests (to specify which information or service is desired) and 
the responses (the matching data, or info on the service rendered) 
are <span class='xquote'>&ldquo;serialized&rdquo;</span> into textual representations.  The preferred 
representations of web <span class='acronym'>API</span>s are human-readable but also 
follow strict rules so they can be understood, without confusion, 
by computer programs &mdash; the most common examples being 
<span class='acronym'>XML</span> (Extensible Markup Language), <span class='acronym'>JSON</span> (JavaScript Object Notation), 
and <span class='acronym'>RDF</span> (Resource Description Framework).  The advantage of 
textual representations is that a person (as well as a computer) 
can understand the data being conveyed, directly from the serialized text.  One 
disadvantage, however, is that human-readable encodings 
can be much longer than the equivalent data in computer 
memory.  Reducing the amount of data that needs to be sent 
over a network can save energy, and, in places with limited 
internet connectivity, can be essential for data sharing 
networks to work properly.  In addition, a second disadvantage is 
that more code needs to be programmed to work with textual representations.  
Needing to translate data back and forth between binary form and 
textual serializations can make software harder to develop 
and hard to adapt to evolving data models.
</p>

<p>
As an alternative or supplement to textual <span class='acronym'>API</span>s, <span class='acronym'>NDP</span> uses 
a <span class='xquote'>&ldquo;binary&rdquo;</span> system for data sharing which works on the assumption 
that a core semantic model (or <span class='xquote'>&ldquo;Semantic Kernel&rdquo;</span>) can be 
shared by different components on a network, allowing them to 
exchange data in a concise binary representation.  This is 
facilitated by the <span class='acronym'>NDP</span> <span class='xquote'>&ldquo;Application Semantic Kernel&rdquo;</span> (<span class='acronym'>ASK</span>) 
framework, which is discussed in greater detail <a href='/web/main-info-pages/ask.html'>here</a>.  
This also relies on cross-platform <span class='acronym'>Qt</span> libraries which are 
mature and well-established on many computing environments.  
<span class='acronym-cap'>Qt</span> is first and foremost a front-end, application-development 
framework, but in addition to its <span class='acronym'>GUI</span> classes, <span class='acronym'>Qt</span> 
provides sophisticated networking and data collections libraries 
which can be used both for building data structures and for 
sending them via network protocols like <span class='acronym'>TCP</span> and <span class='acronym'>HTTP</span>.  
<span class='acronym-cap'>Qt</span> provides <span class='xquote'>&ldquo;container&rdquo;</span> classes modeling lists, vectors, 
stacks, queues, key-value maps, and so forth, as well as a 
robust and internationalized string-manipulation and Regular-Expression 
(textual pattern-matching) framework.  Applications with <span class='acronym'>Qt</span>-based front-ends 
will typically use these string and collections classes for underlying data models, 
or at least will find it straightforward to convert structures from 
other formats (like the <span class='acronym'>C++</span> Standard Library).  Once data is 
in a <span class='acronym'>Qt</span>-based format, it requires only several lines of code 
to convert the data into a binary stream, prepared to be 
sent over a network, and then to convert it back to a useful 
run-time format.  This process can be further simplified by 
using a consistent encoding for binary streams, such as 
the <span class='acronym'>NDP</span> version of a base32-encoding (see 
<a href='/web/extra-info-pages/base32.html'>here</a>).
</p>

<p>
Using binary streams to push and then pull data relies upon all 
relevant network points having the code needed 
for the <span class='xquote'>&ldquo;push&rdquo;</span> and <span class='xquote'>&ldquo;pull&rdquo;</span> operations to be 
consistent.  That is, it relies on code being properly shared 
across the network, as well as data.  Implementing 
a Binary <span class='acronym'>API</span> therefore requires both code sharing 
<i>and</i> data sharing, but assuming the code can 
remain consistent and up-to-date (for example, via 
code-sharing platforms like <span class='acronym'>Github</span>), many of the 
difficulties of data-sharing become factored out to the 
code-sharing aspects of the system.  The components 
specific to data sharing become both easier and less costly 
to maintain and also more energy-efficient and cost-effective 
once deployed.  
</p>

<p>
Binary <span class='acronym'>API</span>s are primarily intended to serve native-compiled front-ends 
or native-compiled network points that can install binary libraries.  
As with any <span class='acronym'>API</span>, an end-user does not usually see binary <span class='acronym'>API</span> results 
directly; instead, an application requests information on users' behalf 
and processes the data sent via the <span class='acronym'>API</span> in response, converting it to a 
visual-interactive form.  <span class='acronym'>API</span> data is often wrapped in web pages, 
for users to access within a web browser.  Browser-based access, however, 
can be suboptimal for complex or highly interactive data.  
Browsers do not have the full range of User Interface functionality 
available to native applications, and relying on JavaScript to 
provide interactive features makes web applications subject to 
environmental restrictions through no fault of their own.  For example, 
JavaScript errors on other web pages (seen on other browser tabs) can 
slow the browser's JavaScript engine, making all open pages inoperable.  
For many kinds of data, the best User Experience <span class='acronym'>UX</span> is achieved 
through stand-alone, native-compiled applications that run 
entirely in their own windows, outside of browsers and their  
ecosystem, and not needing continuous internet connectivity.  
While these applications can work with conventional web <span class='acronym'>API</span>s by 
converting <span class='acronym'>XML</span> or <span class='acronym'>JSON</span> code to in-memory data structures, 
it is more effective for native applications to receive data 
which is already in binary form, linking in the same data model 
libraries which are used by the <span class='acronym'>API</span> provider to ensure 
data integrity and interoperability.
</p>

<p>
This is precisely the architecture supported by the <span class='acronym'>NDP</span> Binary <span class='acronym'>API</span> framework, 
through a combination of data modeling, semantic modeling, and networking 
classes.  <span class='acronym-cap'>NDP</span> components can be user-facing front-ends which access 
<span class='acronym'>API</span>s so as to generate specific User Interface components: for example, 
each <span class='acronym'>API</span> can be associated with a single dialog box (a separate window that 
can be closed, minimized, and activated in isolation from other application 
windows, often activated from a context menu in a larger window).  
Alternatively binary <span class='acronym'>API</span> clients can be cloud services that convert the 
binary data into web-friendly formats for use by web clients.  
When used in a native application, <span class='acronym'>GUI</span>-based binary <span class='acronym'>API</span> clients 
can be packaged as isolated, reusable libraries that provide a consistent 
data and visual model for multiple applications.  These components 
are then front-end components with their own data model that can 
send and receive data to their own cloud-based services, and can be 
plugged in to larger native applications with little extra coding 
ln the application developer's part.  Custom 
dialogs are discussed further <a href='/web/main-info-pages/custom-dialogs.html'>here</a>.  
In general, such components group together related pieces of information that are 
specific to a given topic or task but are not usually unified in the same 
conventient form in pre-existing applications.  For example, researchers emphasizing 
a particular topic &mdash; or who have developed innovative techniques and methods 
&mdash; can bundle their data structures into domain-specific visual and netwoking 
units.  Consider a specialist in refugee health adding refugee-related support 
to medical software; or reusable components specific to maternal health 
provided for both medical and educational software; or data aggregates 
specific to new treatment modalities which need to be integrated into 
medical records.  An appliction which can integrate these domain-specific 
visual and data models in a flexible, modular fashion, will be more 
adaptable and more usable in evolving environments.  The Native Driven Platform 
overall is specifically built to support these modular, evolving programming paradigms.
</p>

<p>
The effective combination of data-sharing and code-sharing is not limited 
to binary serialization; the same principles can be used with formats such as 
<span class='acronym'>XML</span>, where the <span class='acronym'>API</span> provider also provides libraries to convert 
<span class='acronym'>XML</span> streams into runtime objects.  For example, <span class='acronym'>Qt</span> provides <span class='acronym'>XML</span> 
and <span class='tlink'>XQuery</span> libraries, and the <span class='acronym'>Qt) Meta-Object System <span class='acronym'>MOC</span> simplifies 
the translation of <span class='tlink'>XQuery</span> results into <span class='acronym'>Qt</span> objects, since 
classes and functions can be identified by name, that is, by identifiers 
obtained from <span class='acronym'>XML</span> data.  The <span class='acronym'>MOC</span> provides <span class='acronym'>C++</span> reflection 
capabilities, at least for classes and functions specifically annotated 
so as to be accessible via reflection.  <span class='acronym-cap'>XML</span> Document Types can 
accordingly be designed to anticipate this usage, if the data types which 
they serialize are part of <span class='acronym'>Qt</span> applications.  In the simplest case, 
a part of a document serializing a single typed value &mdash; which can themselves be 
complex data structures, even if they are one single instance of a complex 
data type &mdash; can be annotated with a class name, wherein the associated 
<span class='acronym'>Qt</span>-compatible class has a constructor that initializes values from 
<span class='acronym'>XQuery</span> results.  An alternative solution is to transform <span class='acronym'>XML</span> data, via 
<span class='acronym'>XQuery</span>, into scripts which initialize values via <span class='acronym'>Qt</span> callbacks &mdash; 
<span class='acronym'>NDP</span> provides an illustration of this tactic based on the <span class='acronym'>Clasp</span> 
scripting language, which is a dialect of <span class='acronym'>Lisp</span> developed by 
Christian Shafmeister at Temple University.  For some projects 
the best solution may be a combination of several forms of <span class='acronym'>API</span> access: 
binary streams, <span class='acronym'>Qt</span>-specific <span class='acronym'>XML</span> documents, and general <span class='acronym'>XML</span> documents 
for different clients, depending on the code available in clients' environment.
</p>

<p>
<span class='acronym-cap'>NDP</span> also gives developers latitude in how <span class='acronym'>API</span> requests are encoded.  
It is certainly possible to use <span class='acronym'>URL</span> parameters or <span class='acronym'>REST</span>-style 
(Representational State Transfer) <span class='xquote'>&ldquo;representational&rdquo;</span> <span class='acronym'>URL</span> to encode 
request details, but it is equally possible to encode and/or encrypt requests 
in raw <span class='acronym'>HTTP</span> data.  Since <span class='acronym'>NDP</span> provides low-level <span class='acronym'>HTTP</span> access, 
programmers are not limited to standardized web protocols (such as 
standardized <span class='acronym'>HTTP</span> methods like <span class='tlink'>get</span>, <span class='tlink'>post</span>, and <span class='tlink'>put</span>), 
or standardized request-body encodings (such as those available for <span class='acronym'>HTML</span> forms).  
Since many <span class='acronym'>NDP</span> clients are native-compiled front-ends, they can 
assemble <span class='acronym'>HTTP</span> requests internally, and can post arbitrary data (including 
binary serializations) in the request body.  Accordingly, the requests themselves 
can be instances of data types with their own semantic models, 
or <span class='xquote'>&ldquo;Semantic Kernel&rdquo;</span>; the design of the semantically rich data types and 
of the <span class='xquote'>&ldquo;Request Objects&rdquo;</span> that obtain information from these types 
can go hand-in-hand.  While developers are free to use more traditional 
<span class='acronym'>REST</span> models (which work best with relatively simple and linear 
data complexes), they can design specialized Request Objects for 
more complex data, or may combine multiple request styles.  
Developers, in short, can <a href='/web/main-info-pages/learn-more.html'
onclick="window.open('/web/main-info-pages/gen/learn-more.html','_self');"
>shape the platform to the 
data</a>, rather than shaping the data to the platform.  
</p>


</div> <!-- main page div -->
 
</body>
</html>
 
